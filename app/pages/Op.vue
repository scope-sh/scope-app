<template>
  <ScopePage
    v-model:section="section"
    :sections="sections"
  >
    <ScopePanelLoading
      v-if="isLoading"
      title="UserOp"
      :subtitle="hash"
    />
    <ScopePanel
      v-if="!isLoading && op === null"
      title="UserOp"
      :subtitle="hash"
    >
      <ScopeEmptyState label="Couldn't find this UserOp">
        <template #actions>
          <ScopeButton
            kind="primary"
            @click="handleOpenAsTransactionClick"
          >
            Open as transaction
          </ScopeButton>
        </template>
      </ScopeEmptyState>
    </ScopePanel>
    <ScopePanel
      v-else-if="opEvent && opUnpacked"
      title="UserOp"
      :subtitle="hash"
    >
      <OpStatus
        :success="opEvent.success"
        :trace-frame="revertTraceFrame"
      />
      <AttributeList>
        <AttributeItem>
          <AttributeItemLabel
            value="Sender"
            note="The account that initiates the operation"
          />
          <AttributeItemValue>
            <LinkAddress :address="opUnpacked.sender" />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem>
          <AttributeItemLabel
            value="Nonce"
            note="The unique operation identifier"
          />
          <AttributeItemValue>
            {{ opUnpacked.nonce }}
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.factory">
          <AttributeItemLabel
            value="Factory"
            note="The contract that deployed the smart account based on the template"
          />
          <AttributeItemValue>
            <LinkAddress :address="opUnpacked.factory" />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.initData">
          <AttributeItemLabel
            value="Init Data"
            note="The initialization parameters and data used to deploy and set up the smart account"
          />
          <AttributeItemValue>
            <ScopeTextView
              :value="opUnpacked.initData"
              size="tiny"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.paymaster">
          <AttributeItemLabel
            value="Paymaster"
            note="The contract that sponsors the gas fees for the operation"
          />
          <AttributeItemValue>
            <LinkAddress :address="opUnpacked.paymaster" />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.paymasterData">
          <AttributeItemLabel
            value="Paymaster Data"
            note="The data used by the paymaster to sponsor the operation"
          />
          <AttributeItemValue>
            <ScopeTextView
              :value="opUnpacked.paymasterData"
              size="tiny"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="size(opUnpacked.signature) > 0">
          <AttributeItemLabel
            value="Signature"
            note="A cryptographic proof generated by sender, verifying the authenticity and integrity of an operation"
          />
          <AttributeItemValue>
            <ScopeTextView
              :value="opUnpacked.signature"
              size="tiny"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="op">
          <AttributeItemLabel
            value="Call Data"
            note="
              The data that is passed to the sender contract, defining the call's destination, value, and parameters
            "
          />
          <AttributeItemValue>
            <div class="input">
              <ScopeToggle
                v-model="selectedCallDataView"
                :options="callDataViewOptions"
              />
              <ViewCallData
                :address="op.sender.toLowerCase() as Address"
                :call-data="op.callData"
                :view="selectedCallDataView"
              />
            </div>
          </AttributeItemValue>
        </AttributeItem>
      </AttributeList>
      <AttributeList>
        <AttributeItem>
          <AttributeItemLabel
            value="Gas Used"
            note="The total amount of gas consumed by the operation execution"
          />
          <AttributeItemValue>
            {{ opEvent.actualGasUsed }}
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="gasPrice">
          <AttributeItemLabel
            value="Gas Price"
            note="The amount of native currency the sender is willing to pay per unit of gas"
          />
          <AttributeItemValue>
            {{ formatGasPrice(gasPrice, true) }}
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem>
          <AttributeItemLabel
            value="Cost"
            note="The total operation fee paid by the sender or paymaster, calculated as gas used multiplied by gas price"
          />
          <AttributeItemValue>
            {{ formatEther(opEvent.actualGasCost, nativeCurrency, true) }}
          </AttributeItemValue>
        </AttributeItem>
      </AttributeList>
      <CardHighlights
        v-if="opUnpacked"
        :op="opUnpacked"
        :logs="logs"
      />
    </ScopePanel>
    <template #section>
      <template v-if="section === SECTION_LOGS">
        <ScopePanelLoading
          v-if="isTransactionReceiptLoading"
          title="Logs"
        />
        <ScopePanel
          v-else
          title="Logs"
        >
          <template #default>
            <ScopeLabelEmptyState
              v-if="!logs.length"
              value="No logs found"
            />
            <div
              v-else
              class="logs"
            >
              <ScopeToggle
                v-model="selectedLogView"
                :options="logViewOptions"
              />
              <CardLog
                v-for="(log, index) in logs"
                :key="index"
                :log="log"
                :view="selectedLogView"
                type="transaction"
              />
            </div>
          </template>
        </ScopePanel>
      </template>
      <template v-if="section === SECTION_TRANSACTION">
        <ScopePanelLoading
          v-if="isTransactionLoading"
          title="Transaction"
        />
        <ScopePanel
          v-else-if="transaction !== null"
          title="Transaction"
        >
          <AttributeList>
            <AttributeItem v-if="transaction.blockNumber">
              <AttributeItemLabel value="Block" />
              <AttributeItemValue>
                <LinkBlock :number="transaction.blockNumber" />
              </AttributeItemValue>
            </AttributeItem>
            <AttributeItem>
              <AttributeItemLabel value="Hash" />
              <AttributeItemValue>
                <LinkTransaction :hash="transaction.hash" />
              </AttributeItemValue>
            </AttributeItem>
            <AttributeItem>
              <AttributeItemLabel value="From" />
              <AttributeItemValue>
                <LinkAddress :address="transaction.from" />
              </AttributeItemValue>
            </AttributeItem>
            <AttributeItem v-if="transaction.to">
              <AttributeItemLabel value="To" />
              <AttributeItemValue>
                <LinkAddress :address="transaction.to" />
              </AttributeItemValue>
            </AttributeItem>
            <AttributeItem v-if="beneficiary">
              <AttributeItemLabel value="Beneficiary" />
              <AttributeItemValue>
                <LinkAddress :address="beneficiary" />
              </AttributeItemValue>
            </AttributeItem>
          </AttributeList>
        </ScopePanel>
      </template>
      <template v-if="section === SECTION_INTERNAL">
        <ScopePanelLoading
          v-if="isLoading"
          title="Internal"
        />
        <ScopePanel
          v-else
          title="Internal"
        >
          <ScopeLabelEmptyState
            v-if="transactionReplay === null"
            value="Internal calls not available"
          />
          <ScopeLabelEmptyState
            v-else-if="transactionReplay.trace.length === 0"
            value="No internal calls found"
          />
          <InternalCalls
            v-else
            :trace="opTrace"
          />
        </ScopePanel>
      </template>
    </template>
  </ScopePage>
</template>

<script setup lang="ts">
import { useHead } from '@unhead/vue';
import type { Address, Hex, Log, Transaction, TransactionReceipt } from 'viem';
import { size, slice } from 'viem';
import { computed, onMounted, ref, watch } from 'vue';
import { useRouter } from 'vue-router';

import type { LogView } from '@/components/__common/CardLog.vue';
import CardLog from '@/components/__common/CardLog.vue';
import LinkAddress from '@/components/__common/LinkAddress.vue';
import LinkBlock from '@/components/__common/LinkBlock.vue';
import LinkTransaction from '@/components/__common/LinkTransaction.vue';
import ScopeButton from '@/components/__common/ScopeButton.vue';
import ScopeEmptyState from '@/components/__common/ScopeEmptyState.vue';
import ScopeLabelEmptyState from '@/components/__common/ScopeLabelEmptyState.vue';
import type { Section } from '@/components/__common/ScopePage.vue';
import ScopePage from '@/components/__common/ScopePage.vue';
import ScopePanel from '@/components/__common/ScopePanel.vue';
import ScopePanelLoading from '@/components/__common/ScopePanelLoading.vue';
import ScopeTextView from '@/components/__common/ScopeTextView.vue';
import type { Option as ToggleOption } from '@/components/__common/ScopeToggle.vue';
import ScopeToggle from '@/components/__common/ScopeToggle.vue';
import {
  AttributeItem,
  AttributeItemLabel,
  AttributeItemValue,
  AttributeList,
} from '@/components/__common/attributes';
import CardHighlights from '@/components/op/CardHighlights.vue';
import InternalCalls from '@/components/op/InternalCalls.vue';
import OpStatus from '@/components/op/OpStatus.vue';
import type { CallDataView } from '@/components/op/ViewCallData.vue';
import ViewCallData from '@/components/op/ViewCallData.vue';
import useAbi from '@/composables/useAbi';
import useChain from '@/composables/useChain';
import useCommands from '@/composables/useCommands';
import useEnv from '@/composables/useEnv';
import useRoute from '@/composables/useRoute';
import useToast from '@/composables/useToast';
import ApiService from '@/services/api';
import type { TransactionReplay } from '@/services/evm';
import EvmService from '@/services/evm';
import HypersyncService from '@/services/hypersync';
import IndexerService from '@/services/indexer';
import type { Command } from '@/stores/commands';
import { raceNonNull } from '@/utils';
import { ARBITRUM, ARBITRUM_SEPOLIA } from '@/utils/chains';
import type { Op } from '@/utils/context/erc4337/entryPoint';
import {
  getOpEvent,
  getOpHash,
  getOps,
  getBeneficiary,
  getOpLogs,
  unpackOp,
  getEntryPoint,
} from '@/utils/context/erc4337/entryPoint';
import type { OpTrace } from '@/utils/context/traces';
import {
  convertDebugTraceToTransactionTrace,
  convertDebugStateToTransactionStateDiff,
  getChildren as getChildTrace,
  getDirectChildren as getDirectChildTrace,
  getOpTrace,
  getRevert as getRevertTraceFrame,
} from '@/utils/context/traces';
import { formatEther, formatGasPrice } from '@/utils/formatting';
import { type OpRouteLocation, getRouteLocation } from '@/utils/routing';
import { getDelegation } from '~/utils/context/eip7702';

const SECTION_TRANSACTION = 'transaction';
const SECTION_LOGS = 'logs';
const SECTION_INTERNAL = 'internal';

const { setCommands } = useCommands();
const { send: sendToast } = useToast();

const { appBaseUrl, indexerEndpoint } = useEnv();
const route = useRoute<OpRouteLocation>();
const router = useRouter();
const { id: chainId, name: chainName, client, nativeCurrency } = useChain();
const { requestAbi } = useAbi();

const section = ref<Section['value']>(SECTION_LOGS);
const sections = computed<Section[]>(() => [
  {
    label: 'Logs',
    value: SECTION_LOGS,
  },
  {
    label: 'Transaction',
    value: SECTION_TRANSACTION,
  },
  {
    label: 'Internal',
    value: SECTION_INTERNAL,
  },
]);

const hash = computed(() => route.params.hash);

const commands = computed<Command[]>(() => [
  {
    icon: 'copy',
    label: 'Copy UserOp hash',
    act: (): void => {
      if (!hash.value) {
        return;
      }
      navigator.clipboard.writeText(hash.value);
      sendToast({
        type: 'success',
        message: 'UserOp hash copied to clipboard',
      });
    },
  },
]);

watch(
  commands,
  () => {
    setCommands(commands.value);
  },
  {
    immediate: true,
  },
);

onMounted(() => {
  fetch();
});

watch(hash, () => {
  fetch();
});

useHead({
  title: () => `UserOp ${hash.value} on ${chainName.value} | Scope`,
});

const apiService = computed(() =>
  chainId.value ? new ApiService(chainId.value) : null,
);
const evmService = computed(() =>
  client.value ? new EvmService(client.value) : null,
);
const hypersyncService = computed(() =>
  chainId.value ? new HypersyncService(chainId.value, appBaseUrl) : null,
);
const indexerService = computed(() =>
  chainId.value ? new IndexerService(indexerEndpoint, chainId.value) : null,
);

const isLoading = ref(false);
const transaction = ref<Transaction | null>(null);
const transactionReceipt = ref<TransactionReceipt | null>(null);
const transactionReplay = ref<TransactionReplay | null>(null);
const delegates = ref<Record<Address, Address>>({});

const entryPoint = ref<Address | null>(null);
const op = ref<Op | null>(null);
const opData = computed(() => {
  return [transaction.value, transactionReplay.value, delegates.value];
});
watch(opData, async () => {
  if (!transaction.value) {
    return;
  }
  const to = transaction.value.to;
  if (!to) {
    return;
  }
  const chain = chainId.value;
  if (!chain) {
    return;
  }
  const transactonTrace = transactionReplay.value?.trace ?? null;
  entryPoint.value = getEntryPoint(transaction.value, transactonTrace);
  const ops = await getOps(client.value, transaction.value, transactonTrace);
  op.value =
    ops.find((op) => {
      if (!entryPoint.value) {
        return false;
      }
      const delegate = delegates.value[op.sender] ?? null;
      return getOpHash(chain, entryPoint.value, op, delegate) === hash.value;
    }) || null;
});
watch(op, async () => {
  if (!apiService.value) {
    return;
  }
  if (!op.value) {
    return;
  }
  const sender = op.value.sender.toLowerCase() as Address;
  const callData = op.value.callData;

  requestAbi(sender, {
    functions: [slice(callData, 0, 4)],
  });
});
const opUnpacked = computed(() => {
  if (!chainId.value) {
    return null;
  }
  if (!entryPoint.value) {
    return null;
  }
  if (!transactionReceipt.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  if (!hash.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  return unpackOp(hash.value, op.value);
});
const opEvent = computed(() => {
  if (!chainId.value) {
    return null;
  }
  if (!entryPoint.value) {
    return null;
  }
  if (!transactionReceipt.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  const delegate = delegates.value[op.value.sender] ?? null;
  return getOpEvent(
    chainId.value,
    entryPoint.value,
    transactionReceipt.value.logs,
    op.value,
    delegate,
  );
});
const gasPrice = computed(() => {
  if (!opEvent.value) {
    return null;
  }
  return opEvent.value.actualGasCost / opEvent.value.actualGasUsed;
});
const beneficiary = computed<Address | null>(() => {
  if (!transaction.value) {
    return null;
  }
  return getBeneficiary(transaction.value);
});
const logs = computed<Log[]>(() => {
  if (!transactionReceipt.value) {
    return [];
  }
  if (!hash.value) {
    return [];
  }
  return getOpLogs(transactionReceipt.value.logs, hash.value);
});

const isTransactionLoading = ref(false);
const isTransactionReceiptLoading = ref(false);
async function fetch(): Promise<void> {
  isLoading.value = true;
  const txHash = await getTxHashByOp(hash.value);
  if (!txHash) {
    isLoading.value = false;
    return;
  }
  await Promise.all([
    fetchTransaction(txHash),
    fetchTransactionReceipt(txHash),
    fetchTransactionReplay(txHash),
  ]);
  await fetchDelegates();
  isLoading.value = false;
  await fetchAbis();
}

async function getTxHashByOp(hash: Hex): Promise<Hex | null> {
  if (!hypersyncService.value || !indexerService.value) {
    return null;
  }
  // Race to get the tx hash from hypersync or indexer
  // But ignore the promise if it resolves as null
  const hypersyncRequest = hypersyncService.value.getOpTxHash(hash);
  const indexerRequest = indexerService.value.getTxHashByOpHash(hash);
  const txHash = await raceNonNull([hypersyncRequest, indexerRequest]);
  if (!txHash) {
    return null;
  }
  return txHash;
}

async function fetchTransaction(txHash: Address): Promise<void> {
  if (!evmService.value) {
    return;
  }
  isTransactionLoading.value = true;
  transaction.value = await evmService.value.getTransaction(txHash);
  isTransactionLoading.value = false;
}

async function fetchTransactionReceipt(txHash: Address): Promise<void> {
  if (!evmService.value) {
    return;
  }
  isTransactionReceiptLoading.value = true;
  transactionReceipt.value =
    await evmService.value.getTransactionReceipt(txHash);
  isTransactionReceiptLoading.value = false;
}

async function fetchTransactionReplay(txHash: Hex): Promise<void> {
  if (!evmService.value) {
    return;
  }
  if (chainId.value === ARBITRUM || chainId.value === ARBITRUM_SEPOLIA) {
    const [debugTrace, debugState] = await Promise.all([
      evmService.value.getDebugTransactionTrace(txHash),
      evmService.value.getDebugTransactionState(txHash),
    ]);
    const trace = convertDebugTraceToTransactionTrace(debugTrace);
    const stateDiff = convertDebugStateToTransactionStateDiff(debugState);
    if (!trace || !stateDiff) {
      transactionReplay.value = null;
    } else {
      transactionReplay.value = {
        trace,
        stateDiff,
      };
    }
  } else {
    transactionReplay.value =
      await evmService.value.getTransactionReplay(txHash);
  }
}
const opTrace = computed<OpTrace | null>(() => {
  if (!transactionReplay.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  return getOpTrace(transactionReplay.value.trace, hash.value, op.value.sender);
});
const revertTraceFrame = computed(() => {
  if (!opTrace.value) {
    return null;
  }
  const root = opTrace.value.execution[0];
  if (!root) {
    return null;
  }
  const directChildTrace = getDirectChildTrace(opTrace.value.execution, root);
  for (const traceFrame of directChildTrace) {
    const childTrace = getChildTrace(opTrace.value.execution, traceFrame);
    const revertTraceFrame = getRevertTraceFrame(childTrace, traceFrame);
    if (revertTraceFrame) {
      return revertTraceFrame;
    }
  }
  return null;
});

async function fetchAbis(): Promise<void> {
  if (!apiService.value) {
    return;
  }
  if (!transaction.value) {
    return;
  }
  const address = transaction.value.to;
  if (!address) {
    return;
  }
  if (!transactionReceipt.value) {
    return;
  }
  const logs = transactionReceipt.value.logs;
  for (const log of logs) {
    if (!log.address) {
      continue;
    }
    if (log.topics.length === 0) {
      continue;
    }
    const topic = log.topics[0];
    if (!topic) {
      continue;
    }
    requestAbi(log.address, {
      functions: [],
      events: [topic],
      errors: [],
    });
  }
  if (!opTrace.value) {
    return;
  }
  const opTraces = [
    ...opTrace.value.creation,
    ...opTrace.value.validation,
    ...opTrace.value.payment,
    ...opTrace.value.execution,
  ];
  for (const call of opTraces) {
    if (call.type !== 'call') {
      continue;
    }
    const to = call.action.to;
    const input = call.action.input;
    requestAbi(to, {
      functions: size(input) > 0 ? [input.slice(0, 10) as Hex] : [],
      events: [],
      errors: [],
    });
    if (call.error !== null) {
      const output = call.result.output;
      if (!output) {
        continue;
      }
      requestAbi(to, {
        functions: [],
        events: [],
        errors: size(output) > 0 ? [output.slice(0, 10) as Hex] : [],
      });
    }
  }
}

async function fetchDelegates(): Promise<void> {
  delegates.value = {};
  if (!transaction.value) {
    return;
  }
  const transactonTrace = transactionReplay.value?.trace ?? null;
  const ops = await getOps(client.value, transaction.value, transactonTrace);
  const senders = ops.map((op) => op.sender);
  const codes = await Promise.all(
    senders.map((sender) => {
      if (!evmService.value) {
        return null;
      }
      if (!transaction.value) {
        return null;
      }
      const blockNumber = transaction.value.blockNumber;
      if (!blockNumber) {
        return null;
      }
      return evmService.value.getCode(sender, blockNumber);
    }),
  );
  delegates.value = senders.reduce((acc, sender, index) => {
    const code = codes[index];
    if (!code) {
      return acc;
    }
    return { ...acc, [sender]: getDelegation(code) };
  }, {});
}

const selectedCallDataView = ref<CallDataView>('execution');
const callDataViewOptions = computed<ToggleOption<CallDataView>[]>(() => [
  {
    value: 'execution',
    icon: 'hamburger',
  },
  {
    value: 'decoded',
    icon: 'text',
  },
  {
    value: 'hex',
    icon: 'hex-string',
  },
]);
const selectedLogView = ref<LogView>('decoded');
const logViewOptions = computed<ToggleOption<LogView>[]>(() => [
  {
    value: 'decoded',
    icon: 'text',
  },
  {
    value: 'hex',
    icon: 'hex-string',
  },
]);

function handleOpenAsTransactionClick(): void {
  router.push(getRouteLocation({ name: 'transaction', hash: hash.value }));
}
</script>

<style scoped>
.input {
  display: flex;
  gap: var(--spacing-2);
  flex-direction: column;
  width: 100%;
}

.logs {
  display: flex;
  gap: var(--spacing-5);
  flex-direction: column;
}
</style>
