<template>
  <ScopePage
    v-model:section="section"
    :sections="sections"
  >
    <ScopePanel
      v-if="opUnpacked && hash"
      title="Simulated UserOp"
      :subtitle="hash"
    >
      <template #header>
        <div
          class="action"
          @click="handleCopyClick"
        >
          <ScopeIcon
            kind="copy"
            class="icon"
          />
          Copy URL
        </div>
      </template>
      <OpStatus
        v-if="opStatus !== null"
        :success="opStatus"
        :trace-frame="revertTraceFrame"
      />
      <AttributeList>
        <AttributeItem>
          <AttributeItemLabel
            value="Sender"
            note="The account that initiates the operation"
          />
          <AttributeItemValue>
            <LinkAddress :address="opUnpacked.sender" />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem>
          <AttributeItemLabel
            value="Nonce"
            note="The unique operation identifier"
          />
          <AttributeItemValue>
            {{ opUnpacked.nonce }}
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.factory">
          <AttributeItemLabel
            value="Factory"
            note="The contract that deployed the smart account based on the template"
          />
          <AttributeItemValue>
            <LinkAddress
              :address="opUnpacked.factory.toLowerCase() as Address"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.initData">
          <AttributeItemLabel
            value="Init Data"
            note="The initialization parameters and data used to deploy and set up the smart account"
          />
          <AttributeItemValue>
            <ScopeTextView
              :value="opUnpacked.initData"
              size="tiny"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.paymaster">
          <AttributeItemLabel
            value="Paymaster"
            note="The contract that sponsors the gas fees for the operation"
          />
          <AttributeItemValue>
            <LinkAddress :address="opUnpacked.paymaster" />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opUnpacked.paymasterData">
          <AttributeItemLabel
            value="Paymaster Data"
            note="The data used by the paymaster to sponsor the operation"
          />
          <AttributeItemValue>
            <ScopeTextView
              :value="opUnpacked.paymasterData"
              size="tiny"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="size(opUnpacked.signature) > 0">
          <AttributeItemLabel
            value="Signature"
            note="A cryptographic proof generated by sender, verifying the authenticity and integrity of an operation"
          />
          <AttributeItemValue>
            <ScopeTextView
              :value="opUnpacked.signature"
              size="tiny"
            />
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="op">
          <AttributeItemLabel
            value="Call Data"
            note="
              The data that is passed to the sender contract, defining the call's destination, value, and parameters
            "
          />
          <AttributeItemValue>
            <div class="input">
              <ScopeToggle
                v-model="selectedCallDataView"
                :options="callDataViewOptions"
              />
              <ViewCallData
                :address="op.sender.toLowerCase() as Address"
                :call-data="op.callData"
                :view="selectedCallDataView"
              />
            </div>
          </AttributeItemValue>
        </AttributeItem>
      </AttributeList>
      <AttributeList>
        <AttributeItem v-if="opEvent">
          <AttributeItemLabel
            value="Gas Used"
            note="The total amount of gas consumed by the operation execution"
          />
          <AttributeItemValue>
            {{ opEvent.actualGasUsed }}
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="gasPrice">
          <AttributeItemLabel
            value="Gas Price"
            note="The amount of native currency the sender is willing to pay per unit of gas"
          />
          <AttributeItemValue>
            {{ formatGasPrice(gasPrice, true) }}
          </AttributeItemValue>
        </AttributeItem>
        <AttributeItem v-if="opEvent">
          <AttributeItemLabel
            value="Cost"
            note="The total operation fee paid by the sender or paymaster, calculated as gas used multiplied by gas price"
          />
          <AttributeItemValue>
            {{ formatEther(opEvent.actualGasCost, nativeCurrency, true) }}
          </AttributeItemValue>
        </AttributeItem>
      </AttributeList>
      <CardHighlights
        v-if="opUnpacked"
        :op="opUnpacked"
        :logs="transactionLogs || []"
      />
    </ScopePanel>
    <template #section>
      <template v-if="section === SECTION_LOGS">
        <ScopePanelLoading
          v-if="isTransactionReceiptLoading"
          title="Logs"
        />
        <ScopePanel
          v-else
          title="Logs"
        >
          <template #default>
            <ScopeLabelEmptyState
              v-if="!transactionLogs"
              value="Simulation logs not available"
            />
            <ScopeLabelEmptyState
              v-else-if="!transactionLogs.length"
              value="No logs found"
            />
            <div
              v-else
              class="logs"
            >
              <ScopeToggle
                v-model="selectedLogView"
                :options="logViewOptions"
              />
              <CardLog
                v-for="(log, index) in transactionLogs"
                :key="index"
                :log="log"
                :view="selectedLogView"
                type="transaction"
              />
            </div>
          </template>
        </ScopePanel>
      </template>
      <template v-if="section === SECTION_INTERNAL">
        <PanelTraces
          :is-loading="isLoading"
          :op-trace
          :state-diff
          :revert-phase
        />
      </template>
    </template>
  </ScopePage>
</template>

<script setup lang="ts">
import { useHead } from '@unhead/vue';
import type { Address, Hex, Log } from 'viem';
import {
  decodeErrorResult,
  encodeFunctionData,
  numberToHex,
  size,
  slice,
} from 'viem';
import {
  entryPoint06Abi,
  entryPoint06Address,
  entryPoint07Abi,
  entryPoint07Address,
} from 'viem/account-abstraction';
import { computed, ref, onMounted, watch } from 'vue';

import type { LogView } from '@/components/__common/CardLog.vue';
import CardLog from '@/components/__common/CardLog.vue';
import LinkAddress from '@/components/__common/LinkAddress.vue';
import ScopeIcon from '@/components/__common/ScopeIcon.vue';
import ScopeLabelEmptyState from '@/components/__common/ScopeLabelEmptyState.vue';
import type { Section } from '@/components/__common/ScopePage.vue';
import ScopePage from '@/components/__common/ScopePage.vue';
import ScopePanel from '@/components/__common/ScopePanel.vue';
import ScopePanelLoading from '@/components/__common/ScopePanelLoading.vue';
import ScopeTextView from '@/components/__common/ScopeTextView.vue';
import type { Option as ToggleOption } from '@/components/__common/ScopeToggle.vue';
import ScopeToggle from '@/components/__common/ScopeToggle.vue';
import {
  AttributeItem,
  AttributeItemLabel,
  AttributeItemValue,
  AttributeList,
} from '@/components/__common/attributes';
import CardHighlights from '@/components/op/CardHighlights.vue';
import OpStatus from '@/components/op/OpStatus.vue';
import PanelTraces from '@/components/op/PanelTraces.vue';
import type { CallDataView } from '@/components/op/ViewCallData.vue';
import ViewCallData from '@/components/op/ViewCallData.vue';
import useAbi from '@/composables/useAbi';
import useChain from '@/composables/useChain';
import useCommands from '@/composables/useCommands';
import useRoute from '@/composables/useRoute';
import useToast from '@/composables/useToast';
import ApiService from '@/services/api';
import type {
  TransactionReplay,
  TransactionStateDiff,
  TransactionTraceFrame,
} from '@/services/evm';
import EvmService from '@/services/evm';
import type { Command } from '@/stores/commands';
import { ARBITRUM, ARBITRUM_NOVA, ARBITRUM_SEPOLIA } from '@/utils/chains';
import { getDelegation } from '@/utils/context/eip7702';
import type {
  Op,
  Op_0_6,
  Op_0_7,
  Op_0_8,
  Phase,
} from '@/utils/context/erc4337/entryPoint';
import {
  getOpEvent,
  getOpHash,
  getOpLogs,
  getPhaseByEntryPointError,
  unpackOp,
} from '@/utils/context/erc4337/entryPoint';
import type { OpTrace, OpTraceFrame } from '@/utils/context/traces';
import {
  convertDebugTraceToTransactionTrace,
  convertDebugStateToTransactionStateDiff,
  getOpTrace,
  getRevert as getRevertTraceFrame,
} from '@/utils/context/traces';
import { formatEther, formatGasPrice } from '@/utils/formatting';
import type { OpSimulationRouteLocation } from '@/utils/routing';

const SECTION_LOGS = 'logs';
const SECTION_INTERNAL = 'internal';

const MOCK_BUNDLER = '0x0000000000000000000000000000000000000001';

const { setCommands } = useCommands();
const { send: sendToast } = useToast();

const route = useRoute<OpSimulationRouteLocation>();
const { id: chainId, client, name: chainName, nativeCurrency } = useChain();
const { requestAbi } = useAbi();

const section = ref<Section['value']>(SECTION_INTERNAL);
const sections = computed<Section[]>(() => [
  {
    label: 'Internal',
    value: SECTION_INTERNAL,
  },
  {
    label: 'Logs',
    value: SECTION_LOGS,
  },
]);

const entryPoint = computed(
  () => route.query.entryPoint as Address | undefined,
);
const sender = computed(() => route.query.sender as Address | undefined);
const nonce = computed(() => route.query.nonce as Hex | undefined);
const initCode = computed(() => route.query.initCode as Hex | undefined);
const callData = computed(() => route.query.callData as Hex | undefined);
const accountGasLimits = computed(
  () => route.query.accountGasLimits as Hex | undefined,
);
const preVerificationGas = computed(
  () => route.query.preVerificationGas as Hex | undefined,
);
const gasFees = computed(() => route.query.gasFees as Hex | undefined);
const paymasterAndData = computed(
  () => route.query.paymasterAndData as Hex | undefined,
);
const signature = computed(() => route.query.signature as Hex | undefined);
const block = computed(() => route.query.blockNumber);

const delegate = ref<Address | null>(null);
const op = computed<Op | null>(() => {
  if (!sender.value) {
    return null;
  }
  if (!nonce.value) {
    return null;
  }
  if (!initCode.value) {
    return null;
  }
  if (!callData.value) {
    return null;
  }
  if (!accountGasLimits.value) {
    return null;
  }
  if (!preVerificationGas.value) {
    return null;
  }
  if (!gasFees.value) {
    return null;
  }
  if (!paymasterAndData.value) {
    return null;
  }
  if (!signature.value) {
    return null;
  }
  if (entryPoint.value === entryPoint06Address.toLowerCase()) {
    return {
      sender: sender.value,
      nonce: BigInt(nonce.value),
      initCode: initCode.value,
      callData: callData.value,
      verificationGasLimit: BigInt(slice(accountGasLimits.value, 0, 16)),
      callGasLimit: BigInt(slice(accountGasLimits.value, 16)),
      preVerificationGas: BigInt(preVerificationGas.value),
      maxFeePerGas: BigInt(slice(gasFees.value, 0, 16)),
      maxPriorityFeePerGas: BigInt(slice(gasFees.value, 16)),
      paymasterAndData: paymasterAndData.value,
      signature: signature.value,
    } as Op_0_6;
  } else if (entryPoint.value === entryPoint07Address.toLowerCase()) {
    return {
      sender: sender.value,
      nonce: BigInt(nonce.value),
      initCode: initCode.value,
      callData: callData.value,
      accountGasLimits: accountGasLimits.value,
      preVerificationGas: BigInt(preVerificationGas.value),
      gasFees: gasFees.value,
      paymasterAndData: paymasterAndData.value,
      signature: signature.value,
    } as Op_0_7;
  } else {
    return {
      sender: sender.value,
      nonce: BigInt(nonce.value),
      initCode: initCode.value,
      callData: callData.value,
      accountGasLimits: accountGasLimits.value,
      preVerificationGas: BigInt(preVerificationGas.value),
      gasFees: gasFees.value,
      paymasterAndData: paymasterAndData.value,
      signature: signature.value,
    } as Op_0_8;
  }
});
const hash = computed(() =>
  op.value && entryPoint.value
    ? getOpHash(chainId.value, entryPoint.value, op.value, delegate.value)
    : null,
);

const commands = computed<Command[]>(() => [
  {
    icon: 'copy',
    label: 'Copy page URL',
    act: (): void => {
      navigator.clipboard.writeText(window.location.href);
      sendToast({
        type: 'success',
        message: 'Page URL copied to clipboard',
      });
    },
  },
  {
    icon: 'copy',
    label: 'Copy UserOp hash',
    act: (): void => {
      if (!hash.value) {
        return;
      }
      navigator.clipboard.writeText(hash.value);
      sendToast({
        type: 'success',
        message: 'UserOp hash copied to clipboard',
      });
    },
  },
]);

watch(
  commands,
  () => {
    setCommands(commands.value);
  },
  {
    immediate: true,
  },
);

onMounted(() => {
  fetch();
});

watch(hash, () => {
  fetch();
});

useHead({
  title: () => `Simulated UserOp ${hash.value} on ${chainName.value} | Scope`,
});

const apiService = computed(() =>
  chainId.value ? new ApiService(chainId.value) : null,
);
const evmService = computed(() =>
  client.value ? new EvmService(client.value) : null,
);

const isLoading = ref(false);
const transactionLogs = ref<Log[] | null>(null);
const transactionReplay = ref<TransactionReplay | null>(null);

watch(op, async () => {
  if (!apiService.value) {
    return;
  }
  if (!op.value) {
    return;
  }
  const sender = op.value.sender.toLowerCase() as Address;
  const callData = op.value.callData;

  requestAbi(sender, {
    functions: [slice(callData, 0, 4)],
  });
});
const opUnpacked = computed(() => {
  if (!chainId.value) {
    return null;
  }
  if (!entryPoint.value) {
    return null;
  }
  if (!hash.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  return unpackOp(hash.value, op.value);
});
const opEvent = computed(() => {
  if (!chainId.value) {
    return null;
  }
  if (!entryPoint.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  return getOpEvent(
    chainId.value,
    entryPoint.value,
    opLogs.value,
    op.value,
    delegate.value,
  );
});
const opStatus = computed(() => {
  if (!transactionReplay.value) {
    return null;
  }
  if (!opEvent.value) {
    return false;
  }
  return opEvent.value.success;
});
const gasPrice = computed(() => {
  if (!opEvent.value) {
    return null;
  }
  return opEvent.value.actualGasCost / opEvent.value.actualGasUsed;
});
const opLogs = computed<Log[]>(() => {
  if (!hash.value) {
    return [];
  }
  if (!transactionLogs.value) {
    return [];
  }
  return getOpLogs(transactionLogs.value, hash.value);
});

const isTransactionReceiptLoading = ref(false);
async function fetch(): Promise<void> {
  if (!entryPoint.value) {
    return;
  }
  if (!op.value) {
    return;
  }
  isLoading.value = true;
  await Promise.all([
    fetchTransactionLogs(entryPoint.value, op.value),
    fetchTransactionReplay(entryPoint.value, op.value),
    fetchDelegates(),
  ]);
  isLoading.value = false;
  await fetchAbis();
}

async function fetchTransactionLogs(
  entryPoint: Address,
  op: Op,
): Promise<void> {
  if (!evmService.value) {
    return;
  }
  const opData =
    'gasFees' in op
      ? encodeFunctionData({
          abi: entryPoint07Abi,
          functionName: 'handleOps',
          args: [[op], MOCK_BUNDLER],
        })
      : encodeFunctionData({
          abi: entryPoint06Abi,
          functionName: 'handleOps',
          args: [[op], MOCK_BUNDLER],
        });
  transactionLogs.value = await evmService.value.getCallLogs({
    from: MOCK_BUNDLER,
    to: entryPoint,
    value: BigInt(0),
    data: opData,
    blockNumber: block.value,
  });
}

async function fetchTransactionReplay(
  entryPoint: Address,
  op: Op,
): Promise<void> {
  if (!evmService.value) {
    return;
  }
  const opData =
    'gasFees' in op
      ? encodeFunctionData({
          abi: entryPoint07Abi,
          functionName: 'handleOps',
          args: [[op], MOCK_BUNDLER],
        })
      : encodeFunctionData({
          abi: entryPoint06Abi,
          functionName: 'handleOps',
          args: [[op], MOCK_BUNDLER],
        });
  const blockReference = block.value ? numberToHex(block.value) : 'latest';
  if (
    chainId.value === ARBITRUM ||
    chainId.value === ARBITRUM_SEPOLIA ||
    chainId.value === ARBITRUM_NOVA
  ) {
    const [debugTrace, debugState] = await Promise.all([
      evmService.value.getDebugCallTrace(
        {
          from: MOCK_BUNDLER,
          to: entryPoint,
          data: opData,
        },
        blockReference,
      ),
      evmService.value.getDebugCallState(
        {
          from: MOCK_BUNDLER,
          to: entryPoint,
          data: opData,
        },
        blockReference,
      ),
    ]);
    const trace = convertDebugTraceToTransactionTrace(debugTrace);
    const stateDiff = convertDebugStateToTransactionStateDiff(debugState);
    if (!trace || !stateDiff) {
      transactionReplay.value = null;
    } else {
      transactionReplay.value = {
        trace,
        stateDiff,
      };
    }
  } else {
    transactionReplay.value = await evmService.value.getCallReplay(
      {
        from: MOCK_BUNDLER,
        to: entryPoint,
        value: BigInt(0),
        data: opData,
      },
      blockReference,
    );
  }
}
const opTrace = computed<OpTrace | null>(() => {
  if (!transactionReplay.value) {
    return null;
  }
  if (!op.value) {
    return null;
  }
  if (!hash.value) {
    return null;
  }
  return getOpTrace(transactionReplay.value.trace, hash.value, op.value.sender);
});
const stateDiff = computed<TransactionStateDiff | null>(() => {
  if (!transactionReplay.value) {
    return null;
  }
  // Remove bundler address from state diff
  const stateDiff = transactionReplay.value.stateDiff;
  if (!stateDiff) {
    return null;
  }
  return Object.fromEntries(
    Object.entries(stateDiff).filter(([address]) => address !== MOCK_BUNDLER),
  );
});
const revertTraceFrame = computed(() => {
  if (!transactionReplay.value) {
    return null;
  }
  const trace = transactionReplay.value.trace;
  const root = trace.find((trace) => trace.traceAddress.length === 0);
  if (!root) {
    return null;
  }
  return getRevertTraceFrame(trace, root);
});

const revertPhase = computed<Phase | undefined>(() => {
  function isMatch(
    frame: TransactionTraceFrame,
    phaseFrames: OpTraceFrame[],
  ): boolean {
    for (const phaseFrame of phaseFrames) {
      if (frame.traceAddress.length !== phaseFrame.fullTraceAddress.length) {
        continue;
      }
      if (
        frame.traceAddress.every(
          (value, index) => value === phaseFrame.fullTraceAddress[index],
        )
      ) {
        return true;
      }
    }
    return false;
  }

  if (!revertTraceFrame.value) {
    return undefined;
  }
  if (!opTrace.value) {
    return undefined;
  }
  // First, try to find a matching trace in each phase
  if (isMatch(revertTraceFrame.value, opTrace.value.creation)) {
    return 'creation';
  }
  if (isMatch(revertTraceFrame.value, opTrace.value.validation)) {
    return 'validation';
  }
  if (isMatch(revertTraceFrame.value, opTrace.value.payment)) {
    return 'payment';
  }
  if (isMatch(revertTraceFrame.value, opTrace.value.execution)) {
    return 'execution';
  }

  // Second, try to get a phase by decoding the revert
  if (revertTraceFrame.value.type !== 'call') {
    return undefined;
  }
  if (revertTraceFrame.value.action.to !== entryPoint.value) {
    return 'execution';
  }
  const error = revertTraceFrame.value.error;
  if (error !== 'Reverted') {
    return undefined;
  }
  const errorData = revertTraceFrame.value.result.output;
  if (!errorData) {
    return undefined;
  }
  const decodedError = decodeErrorResult({
    abi:
      entryPoint.value === entryPoint06Address
        ? entryPoint06Abi
        : entryPoint07Abi,
    data: errorData,
  });
  if (
    decodedError.errorName !== 'FailedOp' &&
    decodedError.errorName !== 'FailedOpWithRevert'
  ) {
    return undefined;
  }
  const reason = decodedError.args[1];
  return getPhaseByEntryPointError(reason);
});

async function fetchAbis(): Promise<void> {
  if (!apiService.value) {
    return;
  }
  if (!transactionLogs.value) {
    return;
  }
  for (const log of transactionLogs.value) {
    if (!log.address) {
      continue;
    }
    if (log.topics.length === 0) {
      continue;
    }
    const topic = log.topics[0];
    if (!topic) {
      continue;
    }
    requestAbi(log.address, {
      functions: [],
      events: [topic],
      errors: [],
    });
  }
  if (!transactionReplay.value) {
    return;
  }
  const rootTraceFrame = transactionReplay.value.trace[0];
  if (!rootTraceFrame) {
    return;
  }
  if (!opTrace.value) {
    return;
  }
  const opTraces = [
    rootTraceFrame,
    ...opTrace.value.creation,
    ...opTrace.value.validation,
    ...opTrace.value.payment,
    ...opTrace.value.execution,
  ];
  for (const call of opTraces) {
    if (call.type !== 'call') {
      continue;
    }
    const to = call.action.to;
    const input = call.action.input;
    requestAbi(to, {
      functions: size(input) > 0 ? [input.slice(0, 10) as Hex] : [],
      events: [],
      errors: [],
    });
    if (call.error !== null) {
      const output = call.result.output;
      if (!output) {
        continue;
      }
      requestAbi(to, {
        functions: [],
        events: [],
        errors: size(output) > 0 ? [output.slice(0, 10) as Hex] : [],
      });
    }
  }
}

async function fetchDelegates(): Promise<void> {
  delegate.value = null;
  if (!op.value) {
    return;
  }
  if (!evmService.value) {
    return;
  }
  const sender = op.value.sender;
  if (!sender) {
    return;
  }
  const code = await evmService.value.getCode(sender);
  if (!code) {
    return;
  }
  delegate.value = getDelegation(sender);
}

const selectedCallDataView = ref<CallDataView>('execution');
const callDataViewOptions = computed<ToggleOption<CallDataView>[]>(() => [
  {
    value: 'execution',
    icon: 'hamburger',
  },
  {
    value: 'decoded',
    icon: 'text',
  },
  {
    value: 'hex',
    icon: 'hex-string',
  },
]);
const selectedLogView = ref<LogView>('decoded');
const logViewOptions = computed<ToggleOption<LogView>[]>(() => [
  {
    value: 'decoded',
    icon: 'text',
  },
  {
    value: 'hex',
    icon: 'hex-string',
  },
]);

function handleCopyClick(): void {
  copyPageUrl();
}
function copyPageUrl(): void {
  if (!hash.value) {
    return;
  }
  navigator.clipboard.writeText(window.location.href);
  sendToast({
    type: 'success',
    message: 'Page URL copied to clipboard',
  });
}
</script>

<style scoped>
.input {
  display: flex;
  gap: var(--spacing-2);
  flex-direction: column;
  width: 100%;
}

.logs {
  display: flex;
  gap: var(--spacing-5);
  flex-direction: column;
}

.action {
  display: flex;
  gap: var(--spacing-4);
  align-items: center;
  color: var(--color-text-secondary);
  font-size: var(--font-size-s);
  cursor: pointer;

  &:hover {
    color: var(--color-text-primary);
  }
}

.icon {
  width: 14px;
  height: 14px;
  cursor: pointer;
}
</style>
